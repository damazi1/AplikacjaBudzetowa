\chapter{Implementacja systemu}
Rozdział  przedstawia proces implementacji systemu. Omówiono w nim wykorzystane technologie oraz poszczególne warstwy aplikacji. Celem tego rozdziału jest zaprezentowanie działania wykorzystanej architektury oraz korelacje między poszczególnymi elementami systemu.
\section{Backend – logika biznesowa i API}
Warstwa serwerowa odpowiada ze przetwarzanie żądań od warstwy prezentacji oraz za komunikację z bazą danych. Elementy z których jest skonstruowana to m.in. kontrolery, repozytoria, czy pliki konfiguracyjne. Została zrealizowana w oparciu o framework Spring Boot, który upraszcza proces tworzenia aplikacji dzięki zestawowi tzw. starterów.

\subsection*{Spring Boot i ekosystem bibliotek}
Freamework spring boot oferuje moduły oraz biblioteki wykorzystane do budowy REST API, dostępu do baz danych, bezpieczeństwa i testowania. Wykorzystywane biblioteki są deklarowane w pliku \texttt{pom.xml}. Są one wstępnie skonfigurowane. Takie rozwiązanie znacząco zwiększa tępo rozwoju aplikacji, pozwala na lepszą pracę w grupach oraz redukuje ilość kodu szablonowego (ang. \textit{boilerplate code}).
\subsubsection*{Zarządzanie zależnościami i startery}
Spring boot łączy biblioteki w postaci starterów. Pozwala to zminimalizować ryzyko konfliktów wersji oraz skrócić czas konfiguracji. Kluczowe startery wykorzystywane w aplikacji webowej to:
\begin{itemize}
	\item \textbf{spring-boot-starter-web} -- Warstwa HTTP/REST oparta na spring MVC, która udostępnia wbudowany serwer Tomcat. 
	\item \textbf{spring-boot-starter-data-jpa} -- Umożliwia dostęp do relacyjnej bazy danych poprzez JPA (ang. \textit{Java Persistence API}).
	\item \textbf{spring-boot-starter-data-mongodb} -- Pozwala na dostęp do nierelacyjnej bazy MongoDB. 
	\item \textbf{spring-boot-starter-validation} -- Implementuje biblioteki do walidacji danych wejściowych.
	\item \textbf{spring-boot-starter-security} -- Mechanizm uwierzytelniania, autoryzacji i ochrony endpointów.
	\item \textbf{spring-boot-starter-test} -- Środowisko testowe do testów jednostkowych i integracyjnych. 
	\item \textbf{Lombok} -- Redukuje kod szablonowy (gettery, settery, konstruktory).
\end{itemize}
\subsubsection*{Warstwa webowa}
Umożliwia komunikację z wykorzystywaniem standardu REST API (ang. \textit{Representational State Transfer Application Programing Interface}). W warstwie kontrolerów tworzone są endpointy w oparciu o modele z jakimi są związane. Kontroler może implementować obsługę żądań HTTP, takich jak:
\begin{itemize}
	\item POST -- Przesyłanie danych na serwer
	\item GET -- Pobieranie danych z serwera
	\item PUT -- Aktualizowanie danych na serwerze
	\item DELETE -- Usuwanie danych z serwera
\end{itemize}
Mapowanie endpointów w kontrolerze jest pokazane w listingu \ref{lst:java-endpoints}.
\begin{lstlisting}[language={Java}, caption={Przykładowe Endpointy}, label={lst:java-endpoints}]
@RestController 
@RequestMapping("/User") // Wszystkie endpointy zaczynają się od /User
	@PostMapping("/register")		// Dostęp pod POST /User/register
	@GetMapping("/search")			// Dostęp pod GET /User/search
	@PutMapping("/update/{id}")		// Dostęp pod PUT /User/update/{id}
	@DeleteMapping("/delete/{id}")	// Dostęp pod DELETE /User/delete{id}
\end{lstlisting}

Implementacja powyższych endpointów znajduje się w listingach (\ref{lst:java-register}, \ref{lst:java-list}, \ref{lst:java-delete}, \ref{lst:java-update})
\subsubsection*{Dostęp do danych}
Połączenie z bazą danych zostało zrealizowane z wykorzystaniem \\ \texttt{spring-boot-starter-data-mongodb}, który udostępnia spójny model pracy z dokumentową bazą MongoDB. Pozwala mapować obiekty klas na dokumenty i tworzyć repozytoria oparte na interfejsach.

Utworzenie klasy mapowanej do dokumentu wymaga oznaczenia adnotacją \texttt{@Document}, a klucza głównego \texttt{@Id}. Identyfikator przeważnie określa się typem String (listing \ref{lst:java-Account}). 

Warstwa repozytoriów opiera się na interfejsach rozszerzających \texttt{MongoRepository<T, ID>}. Repozytoria pozwalają na podstawie nazw generować implementację metod wyszukujących (listing \ref{lst:java-Repository}).
\begin{lstlisting}[language={Java}, caption={Fragment modelu Account}, label={lst:java-Account}]
@Document
public class Account {
	@Id
	private String id;
	private String name;
	@Size(min = 25, max = 25)
	@Indexed(unique = true)
	private String number;
	private Currency currency;
	private String userId;
	...
\end{lstlisting}
\begin{lstlisting}[language={Java}, caption={Repozytorium dla klasy Account}, label={lst:java-Repository}]
@RepositoryRestResource
public interface AccountRepository extends MongoRepository<Account, String> {
	List<Account> findByUserId(String userId);
	Optional<Account> findByNumber(String number);
}
	\end{lstlisting}
\subsubsection*{Bezpieczeństwo}
Spring Security zapewnia mechanizm uwierzytelniania JWT (ang. \textit{JSON Web Token}) i filtrowania żądań. Token umożliwia autoryzowane połączenie z serwerem dzięki mechanizmowi ciasteczek. Token bezpieczeństwa składa się z trzech części (tab. \ref{tab:JWT}), które zwyczajowo wyglądają w następujący sposób \texttt{xxxxx.yyyyy.zzzzz}. Filtrowanie pozwala m.in. na określenie żądań, które mogą zostać wykonane bez konieczności autoryzacji użytkownika.

\begin{longtable}{|p{3cm}|p{5cm}|p{6cm}|}
		\caption{Struktura tokenu JWT \cite{JWT}}
		\label{tab:JWT} \\
\hline
\textbf{Nawza} & \textbf{struktura} & \textbf{Opis} \\ \hline

Nagłówek (ang. \textit{Header}) &
 \texttt{\{} \newline
 \hspace*{1em}\texttt{"alg": "HS256",} \newline
 \hspace*{1em}\texttt{"typ": "JWT"} \newline
 \texttt{\}} & 
 Nagłówek składa się z wykorzystanego algorytmu oraz z typu użytego tokena. \\ \hline
 Ładunek (ang. \textit{Payload}) &
  \texttt{\{} \newline
 \hspace*{1em}\texttt{"sub": "1234567890",} \newline
 \hspace*{1em}\texttt{"name": "John Doe"} \newline
 \hspace*{1em}\texttt{"admin": "true"} \newline
 \texttt{\}} & 
 Ładunek zawiera roszczenia (ang. \textit{claims}), czyli oświadczenia dotyczące podmiotu i dodatkowe dane. Typy roszczeń to: rejestrowane (ang. \textit{registered}), publiczne (ang. \textit{public}) i prywatne (ang. \textit{private}).
 \\ \hline
  Podpis (ang. \textit{Signature}) &
\texttt{HMACSHA256(} \newline
 \hspace*{1em}\texttt{base64UrlEncode(header)} \newline
 \hspace*{1em}\texttt{+ "."\space +} \newline
 \hspace*{1em}\texttt{base64UrlEncode(payload)} \newline
 \hspace*{1em}\texttt{, secretPassword)} &
  Podpis składa się z zaszyfrowanego nagłówka, ładunku i hasła, które są później przetwarzane przez wybrany algorytm. 
 \\ \hline

\end{longtable}

\subsubsection*{Testowanie}
Narzędzia do wykonywania testów dostarcza \texttt{spring-boot-starter-test}. Testy jednostkowe wykonuje się z wykorzystaniem biblioteki JUnit. Polegają na wysłaniu żądania HTTP do serwera i porównaniu odpowiedzi otrzymanej z oczekiwaną (przykładowe kody odpowiedzi w tabeli \ref{tab:Kody-HTTP}). W testach tego typu ważną cechą jest sprawdzenie wartości granicznych (listing \ref{lst:java-UnitTest}). 

Testy integracyjne pozwalają sprawdzić interakcje między komponentami aplikacji dzięki narzędziu MockMVC.
\subsubsection*{Konfiguracja i uruchamianie}
Konfiguracja środowiska odbywa się w pliku \texttt{application.properties}. Definicja plików \texttt{Dockerfile} oraz \texttt{Docker-compose.yml} pozwala na spójne uruchamianie usług w różnych środowiskach.
\subsection*{Przykładowe fragmenty kodu}
\subsubsection*{rejestracja}
Funkcja rejestracji przyjmuje jako argument obiekt klasy User, który posiada poprawnie uzupełnione ciało (login: String, password: String, role: UserRoles). Jeżeli podane dane są poprawne, zostaje wywołana funkcja szyfrująca hasło, a następnie użytkownik jest zapisywany w bazie danych.
\begin{lstlisting}[language={Java}, caption={Rejestracja użytkownika}, label={lst:java-register}]
@PostMapping("/register")
public String register(@Valid @RequestBody User user) {
	user.setPassword(passwordEncoder.encode(user.getPassword()));
	userRepository.insert(user);
	return "Rejestracja udana";
}
\end{lstlisting}
\subsubsection*{Lista użytkowników}
Funkcja \texttt{getUser()} wykorzystuję metodę z repozytorium, która umożliwia pobranie wszystkich dokumentów i zwraca je.
\begin{lstlisting}[language={Java}, caption={Lista użytkowników}, label={lst:java-list}]
@GetMapping("/list")
public Iterable<User> getUser() {
	return userRepository.findAll();
}
\end{lstlisting}
\subsubsection*{Usuwanie użytkownika}
Funkcja \texttt{deleteUser} przyjmuję jako parametr podany w ścieżce identyfikator użytkownika. Następnie jeżeli istnieje usuwa dokument z bazy danych.
\begin{lstlisting}[language={Java}, caption={Usuwanie użytkownika}, label={lst:java-delete}]
@DeleteMapping("/delete/{id}")
public void deleteUser(@PathVariable String id) {
	userRepository.deleteById(id);
}
\end{lstlisting}
\subsubsection*{Edycja użytkownika}
Funkcja \texttt{updateUser} pozwala zmienić login użytkownikowi. Jako parametr przyjmuję identyfikator podany w ścieżce oraz wymagany login. Jeżeli zostały podane poprawne dane aktualizuje dokument w bazie danych.
\begin{lstlisting}[language={Java}, caption={Edycja użytkownika}, label={lst:java-update}]
@PutMapping("/update/{id}")
public void updateUser(@PathVariable String id, @RequestParam String login) {
	User user = userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));
	user.setLogin(login);
	userRepository.save(user);
}
\end{lstlisting}
\subsubsection*{Test Jednostkowy}
Podany poniżej kod testujący służy do sprawdzenia czy aplikacja jest zabezpieczona przed wysyłaniem przelewów, w których podano graniczną wartość, czyli kwotę 0.0 \$. Oczekiwany status odpowiedzi to 4xx, a zwracana odpowiedź to ,,amount: must be greater then 0''
\begin{lstlisting}[language={Java}, caption={Przykładowy test}, label={lst:java-UnitTest}]
@Test
public void createTransferHandlesBorderTransferAmount() throws Exception {
	this.mockMvc.perform(MockMvcRequestBuilders.post("/Transaction/create/transfer")
	.contentType("application/json")
	.content("{\"fromAccountNumber\":\"1234567890122234569012335\",\"toAccountNumber\":\"1234567890122234569012335\",\"amount\":0.0}"))
	.andExpect(status().is4xxClientError())
	.andExpect(content().string("amount: must be greater than 0"));
}
\end{lstlisting}
\section{Frontend – interfejs użytkownika}
Warstwa prezentacji została zrealizowana w oparciu o bibliotekę React oraz narzędzie budujące Vite. Vite zapewnia szybkie uruchamianie środowiska deweloperskiego oraz prostą integrację z TypeScript. React dostarcza deklaratywny model budowy, który pozwala opisać, jak powinien wyglądać interfejsu użytkownika w danym stanie \cite{Declarative}. 
\subsection*{Struktura projektu}
Struktura katalogów projektu została zaprojektowana w sposób pozwalający rozdzielić warstwy odpowiedzialności. Składa się z takich modułów jak:
\begin{itemize}
	\item Assets - przechowywanie statycznych elementów strony (np. ikony).
	\item Models - Zawiera typy utworzone na potrzeby działania funkcji.
	\item Services - Odpowiada za komunikacje z backendem.
	\item Styles - Przechowuje style w formacie .css.
	\item Context - Obsługuje globalny stan aplikacji.
	\item Components - Zawiera widoki stron i wszystkie elementy takie jak formularze.
\end{itemize}
\subsection*{Typescript}
\textit{Opisać tu dlaczego wykorzystałem ten język jakie ma ,,Plusy''}
Czy ten podrozdział jest nie potrzebny, bo opis języka jest w przeglądzie technologi? 
\subsection*{Interfejs użytkownika}
Interfejs użytkownika wykorzystuje komponenty z biblioteki Ant Design, która oferuje m.in. siatkę (ang. \textit{grid}), formularze (ang. \textit{form}), okna modalne (ang. \textit{modal}) oraz tabele (ang. \textit{table}). Elementy aplikacji pozwalają na spersonalizowanie motywów oraz tłumaczenie treści. Użytkownik może sprawdzić szczegóły profilu lub przejrzeć historię i dane swoich portfeli, które ma przypisane do konta.
\subsection*{Komunikacja z API}
Komunikacja z backendem odbywa się dzięki bibliotece axios, która wysyła żądania do serwera. 
\begin{lstlisting}[caption={Funkcja wyszukująca wszystkie konta użytkownika}, label={lst:TS-service1}]
	export const fetchAccounts= async (): Promise<Accounts[]> =>{
		const id = await fetchUserId();
		try {
			const response = await axios.get(`http://localhost:8080/Account/get/${id.id}`, {
				withCredentials: true,
				headers: {
					'Content-Type': 'application/json'
				}
			});
			return await response.data;
		} catch (error: any) {
			throw new Error(error.message || "Wystąpił błąd podczas pobierania kont");
		}
	}
\end{lstlisting}

\subsection*{Stan aplikacji i interakcje}
Stany są jednym z kluczowych funkcji, które wykorzystuje się w aplikacjach opartych o React. Wykorzystują funkcję haków (hook), które pozwalają używać stanów bez konieczności posiadania klasy. Do zarządzania stanami możemy użyć funkcji useState lub useEffect. Funkcja useState pozwala nam ustawić jakiś status podczas działania strony. Prostym przykładem będzie zmiana motywu strony przez użytkownika. Wtedy status zmienia się z light na dark. UseEffect pozwala wykonać jakąś funkcję lub działanie i wpłynąć na to jaki status zostanie ustawiony. Poniżej znajdują się przykłady zastosowań dla obu funkcji.
\begin{lstlisting}[caption={Wykorzystanie stanów}, label={lst:TS-states}]
const [loginData, setLogin] = useState<string | null>(null);
	
useEffect(() => {
	const fetchLoginData = async () => {
		try {
			const users = await fetchUsers();
			setLogin(users.join('\n'));
		} catch (err: any) {
			message.error(err.response?.data?.error || err.message);
		}
	};
	fetchLoginData();
}, []);
\end{lstlisting}
\section{Baza danych - implementacja i przepływ danych}
Dane przechowywane nierelacyjnej bazie dokumentowej MongoDB. Wspiera ona wydajne zapytania pod typowe przypadki użycia aplikacji budżetowej na przykład: filtrowanie, agregacje po dacie, kategoriach lub użytkownikach. 
\subsubsection*{Przykładowy przepływ danych}
Dane wyświetlane użytkownikowi końcowemu muszą zostać pobrane z bazy, przetworzone przez serwer, i dopiero wtedy zostaną ukazane użytkownikowi. 
\begin{enumerate}
	\item Użytkownik wywołuje operację logowania. Parametry trafiają do API jako JSON.
	\item Warstwa kontrolerów waliduje dane. 
	\item Backend zleca operację repozytorium.
	\item Baza danych analizuje zapytanie oraz zwraca dokumenty w formacie BSON,
	\item Dane są serializowane do JSON i zwracane do frontendu.
\end{enumerate}
\begin{lstlisting}[caption={Przykładowe dane zwracane z bazy}, label={lst:TS-service1}]
[{
	"fromAccountNumber": "3620457673958599558548379",
	"toAccountNumber": "1234567890122234561012335",
	"amount": 50.0,
	"description": "opis",
	"transactionId": "68dfb1d240d00a2221f78809"
}]
\end{lstlisting}
\section{Integracja warstw}
Integracja trzech warstw systemu została zaprojektowana tak, aby zapewnić spójny przepływ danych, określić jednoznaczną specyfikację API oraz przewidywać zachowania w środowiskach deweloperskich.
\subsection*{Umowa API}
Podstawą integracji jest stabilna specyfikacja API \cite{API}. Frontend korzysta z określonego punktu wejścia, a żądania i odpowiedzi wykorzystują obiekty klas w javie oraz odpowiadające im typy w TypeScript w celu komunikacji. Dane wejściowe są walidowane w kontrolerach i zapisywane bądź odczytywane z MongoDB. Takie podejście zapewnia jednoznaczność komunikacji między warstwami i ułatwia wprowadzanie zmian. 
\subsection*{Autoryzacja i pochodzenie żądań}
Mechanizm bezpieczeństwa oparto o tokeny JWT, na których podstawie określana jest tożsamość użytkownika. W środowisku deweloperskim, gdzie frontend i backend działają pod różnymi portami zezwala się na połączenia z innych domen CORS (ang. \textit{Cross-Origin Resource Sharing}) w kontrolowanym zakresie.
\begin{lstlisting}[language={java}, caption={Konfiguracja CROS}, label={lst:Java-CROS}]
public WebMvcConfigurer corsConfigurer() {
	return new WebMvcConfigurer() {
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			registry.addMapping("/**")
			.allowedOrigins("http://localhost:5173")
			.allowedMethods("GET", "POST", "PUT", "DELETE")
			.allowedHeaders(HttpHeaders.AUTHORIZATION, HttpHeaders.CONTENT_TYPE, HttpHeaders.ACCEPT)
			.allowCredentials(true)
			.maxAge(3600);
		}
	};}
\end{lstlisting}
\subsection*{Wydajność i obsługa błędów}
Wydajność integracji osiągnięto poprzez projektowanie zapytań pod konkretne wzorce dostępu z interfejsu użytkownika. Widoki otrzymują jedynie niezbędne pola. W przypadku wystąpienia błędu system zwróci komunikat w ujednoliconym formacie. Dzięki temu frontend może prezentować informacje o błędach w przewidywalny sposób.

\subsection{Konteneryzacja i uruchamianie wieloskładnikowe}
Konteneryzacja umożliwia spójne uruchamianie wszystkich warstw niezależnie od systemu operacyjnego. Aplikacja backendowa posiada utworzony obraz pozwalający na jej płynne uruchamianie i edycję (listing \ref{lst:Docker-build}). Baza danych MongoDB działa w dedykowanym kontenerze z trwałym woluminem, w którym przechowywane są dokumenty. Połączenie kontenerów odbywa się dzięki konfiguracji zawartej w pliku \texttt{docker-compose.yml} (listing \ref{lst:Docker-compose}), który zawiera w sobie informację o obrazach, portach , sieciach, woluminach, zależnościach oraz zmiennych środowiskowych.
\begin{lstlisting}[caption={Budowanie obrazu - Dockerfile}, label={lst:Docker-build}]
FROM maven:3.9.10-eclipse-temurin-21
WORKDIR /app
COPY pom.xml .
COPY src ./src
EXPOSE 8080
CMD ["mvn", "spring-boot:run"]
\end{lstlisting}
\begin{lstlisting}[caption={Fragment pliku konfiguracyjnego compose.yml}, label={lst:Docker-compose}]
app:						// nazwa kontenera
	build:				// budowanie obrazu na podstawie dockerfile
		context: .
		dockerfile: Dockerfile
ports:					// określenie portów
	- "8080:8080"
environment:		// zmienne środowiskowe
	DB_HOST: mongo
	DB_PORT: 27017
	DB_NAME: budget_management_db
networks:				// określenie sieci
	- default
volumes:				// zadeklarowanie współdzielonego folderu 
	- .:/app
depends_on:			// określenie zależności od innych kontenerów
	- mongo
\end{lstlisting}